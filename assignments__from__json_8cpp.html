<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: /home/runner/work/cbmc/cbmc/jbmc/src/java_bytecode/assignments_from_json.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('assignments__from__json_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">assignments_from_json.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="assignments__from__json_8h_source.html">assignments_from_json.h</a>&quot;</code><br />
<code>#include &lt;<a class="el" href="arith__tools_8h_source.html">util/arith_tools.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="array__element__from__pointer_8h_source.html">util/array_element_from_pointer.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="expr__initializer_8h_source.html">util/expr_initializer.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ieee__float_8h_source.html">util/ieee_float.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="json_8h_source.html">util/json.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="symbol__table__base_8h_source.html">util/symbol_table_base.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="unicode_8h_source.html">util/unicode.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="class__identifier_8h_source.html">goto-programs/class_identifier.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="goto__instruction__code_8h_source.html">goto-programs/goto_instruction_code.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="allocate__objects_8h_source.html">ansi-c/allocate_objects.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="ci__lazy__methods__needed_8h_source.html">ci_lazy_methods_needed.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="code__with__references_8h_source.html">code_with_references.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="java__static__initializers_8h_source.html">java_static_initializers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="java__string__literals_8h_source.html">java_string_literals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="java__types_8h_source.html">java_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="java__utils_8h_source.html">java_utils.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for assignments_from_json.cpp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="assignments__from__json_8cpp__incl.svg" width="2180" height="682"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="assignments__from__json_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values passed around between most functions of the recursive deterministic assignment algorithm entered from <a class="el" href="assignments__from__json_8cpp.html#adc3a79527bc14884f08ecef901937cbe">assign_from_json</a>.  <a href="structobject__creation__infot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structget__or__create__reference__resultt.html">get_or_create_reference_resultt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2bcaa10bbe1163fa29d7958e8a11db6c" id="r_a2bcaa10bbe1163fa29d7958e8a11db6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classjava__class__typet.html">java_class_typet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a2bcaa10bbe1163fa29d7958e8a11db6c">followed_class_type</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;symbol_table)</td></tr>
<tr class="separator:a2bcaa10bbe1163fa29d7958e8a11db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62feaacb911cbff0f4cbdf68c6f2528" id="r_ac62feaacb911cbff0f4cbdf68c6f2528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#ac62feaacb911cbff0f4cbdf68c6f2528">has_enum_type</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;symbol_table)</td></tr>
<tr class="separator:ac62feaacb911cbff0f4cbdf68c6f2528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c76aa6635d3a662f9f2ba10d5347738" id="r_a5c76aa6635d3a662f9f2ba10d5347738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a5c76aa6635d3a662f9f2ba10d5347738">is_enum_with_type_equal_to_declaring_type</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;symbol_table, <a class="el" href="classait.html">const</a> <a class="el" href="classjava__class__typet.html">java_class_typet</a> &amp;declaring_class_type)</td></tr>
<tr class="memdesc:a5c76aa6635d3a662f9f2ba10d5347738"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used as a workaround until reference-equal objects defined across several classes are tracked correctly.  <br /></td></tr>
<tr class="separator:a5c76aa6635d3a662f9f2ba10d5347738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a95a65e77b1f26c3a7ab55de9337327" id="r_a7a95a65e77b1f26c3a7ab55de9337327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a7a95a65e77b1f26c3a7ab55de9337327">get_type</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:a7a95a65e77b1f26c3a7ab55de9337327"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the argument has a "@type" key, return the corresponding value, else return an empty optional.  <br /></td></tr>
<tr class="separator:a7a95a65e77b1f26c3a7ab55de9337327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f0fcacbf786b74ade3e2aef34b5c4" id="r_a323f0fcacbf786b74ade3e2aef34b5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a323f0fcacbf786b74ade3e2aef34b5c4">has_id</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:a323f0fcacbf786b74ade3e2aef34b5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the argument has a "@id" key.  <br /></td></tr>
<tr class="separator:a323f0fcacbf786b74ade3e2aef34b5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b055c274a7b9f71152e595d19001f40" id="r_a6b055c274a7b9f71152e595d19001f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a6b055c274a7b9f71152e595d19001f40">is_reference</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:a6b055c274a7b9f71152e595d19001f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the argument has a "@ref" key.  <br /></td></tr>
<tr class="separator:a6b055c274a7b9f71152e595d19001f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b676c4ba71977f626c51ced8aa075a8" id="r_a3b676c4ba71977f626c51ced8aa075a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a3b676c4ba71977f626c51ced8aa075a8">get_id_or_reference_value</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:a3b676c4ba71977f626c51ced8aa075a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique ID of all objects that are reference-equal to this one.  <br /></td></tr>
<tr class="separator:a3b676c4ba71977f626c51ced8aa075a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4969415db571496d7312dce2df54b75d" id="r_a4969415db571496d7312dce2df54b75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a4969415db571496d7312dce2df54b75d">get_enum_id</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;symbol_table)</td></tr>
<tr class="memdesc:a4969415db571496d7312dce2df54b75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique ID for an enum, based on its type and <code>name</code> field.  <br /></td></tr>
<tr class="separator:a4969415db571496d7312dce2df54b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ea9983ba2ce9c9013d0a9e9985772a" id="r_a46ea9983ba2ce9c9013d0a9e9985772a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a46ea9983ba2ce9c9013d0a9e9985772a">has_nondet_length</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:a46ea9983ba2ce9c9013d0a9e9985772a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the argument has a <code>"@nondetLength"<code></code>: true</code> entry.  <br /></td></tr>
<tr class="separator:a46ea9983ba2ce9c9013d0a9e9985772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93485d106b775089cb7a764c6aa4f2e0" id="r_a93485d106b775089cb7a764c6aa4f2e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classjsont.html">jsont</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a93485d106b775089cb7a764c6aa4f2e0">get_untyped</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> std::string &amp;<a class="el" href="classait.html">object_key</a>)</td></tr>
<tr class="memdesc:a93485d106b775089cb7a764c6aa4f2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For typed versions of primitive, string or array types, looks up their untyped contents with the key specific to their type.  <br /></td></tr>
<tr class="separator:a93485d106b775089cb7a764c6aa4f2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95106a6a6b27f89f134e29cea231743f" id="r_a95106a6a6b27f89f134e29cea231743f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classjsont.html">jsont</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a95106a6a6b27f89f134e29cea231743f">get_untyped_primitive</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:a95106a6a6b27f89f134e29cea231743f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="assignments__from__json_8cpp.html#a93485d106b775089cb7a764c6aa4f2e0">get_untyped</a> for primitive types.  <br /></td></tr>
<tr class="separator:a95106a6a6b27f89f134e29cea231743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf13f67d33bcc47ea8f679816972aa14" id="r_abf13f67d33bcc47ea8f679816972aa14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classjson__arrayt.html">json_arrayt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#abf13f67d33bcc47ea8f679816972aa14">get_untyped_array</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> <a class="el" href="classtypet.html">typet</a> &amp;element_type)</td></tr>
<tr class="memdesc:abf13f67d33bcc47ea8f679816972aa14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="assignments__from__json_8cpp.html#a93485d106b775089cb7a764c6aa4f2e0">get_untyped</a> for array types.  <br /></td></tr>
<tr class="separator:abf13f67d33bcc47ea8f679816972aa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7927787bb04cb7712e5cc547584655f" id="r_ac7927787bb04cb7712e5cc547584655f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classjsont.html">jsont</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#ac7927787bb04cb7712e5cc547584655f">get_untyped_string</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:ac7927787bb04cb7712e5cc547584655f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="assignments__from__json_8cpp.html#a93485d106b775089cb7a764c6aa4f2e0">get_untyped</a> for string types.  <br /></td></tr>
<tr class="separator:ac7927787bb04cb7712e5cc547584655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02397c722097a548695ae9fb9f18a8b8" id="r_a02397c722097a548695ae9fb9f18a8b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> std::optional&lt; <a class="el" href="classjava__class__typet.html">java_class_typet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a02397c722097a548695ae9fb9f18a8b8">runtime_type</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;<a class="el" href="classait.html">type_from_array</a>, <a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;symbol_table)</td></tr>
<tr class="memdesc:a02397c722097a548695ae9fb9f18a8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a JSON representation of a (non-array) reference-typed object and a type inferred from the type of a containing array, get the runtime type of the corresponding pointer expression.  <br /></td></tr>
<tr class="separator:a02397c722097a548695ae9fb9f18a8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dafabd375c6f50544c2fa3cb2f9b876" id="r_a3dafabd375c6f50544c2fa3cb2f9b876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a3dafabd375c6f50544c2fa3cb2f9b876">element_type_from_array_type</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;<a class="el" href="classait.html">type_from_array</a>)</td></tr>
<tr class="memdesc:a3dafabd375c6f50544c2fa3cb2f9b876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a JSON representation of an array and a type inferred from the type of a containing array, get the element type by removing the leading '['.  <br /></td></tr>
<tr class="separator:a3dafabd375c6f50544c2fa3cb2f9b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac721bf9c7907cdc3a302f751e21d22e9" id="r_ac721bf9c7907cdc3a302f751e21d22e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;<a class="el" href="classait.html">type_from_array</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:ac721bf9c7907cdc3a302f751e21d22e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point of the recursive deterministic assignment algorithm.  <br /></td></tr>
<tr class="separator:ac721bf9c7907cdc3a302f751e21d22e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37728a4f16cce9746388108fa9d824" id="r_abe37728a4f16cce9746388108fa9d824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#abe37728a4f16cce9746388108fa9d824">assign_primitive_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>)</td></tr>
<tr class="memdesc:abe37728a4f16cce9746388108fa9d824"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the base cases (primitive case) of the recursion.  <br /></td></tr>
<tr class="separator:abe37728a4f16cce9746388108fa9d824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038484071adc18ad6e9d244ec4c72bb6" id="r_a038484071adc18ad6e9d244ec4c72bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__frontend__assignt.html">code_frontend_assignt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a038484071adc18ad6e9d244ec4c72bb6">assign_null</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr)</td></tr>
<tr class="memdesc:a038484071adc18ad6e9d244ec4c72bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the base cases of the recursive algorithm.  <br /></td></tr>
<tr class="separator:a038484071adc18ad6e9d244ec4c72bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd1ef90c22b87ea12c2d564f9170ae" id="r_a00cd1ef90c22b87ea12c2d564f9170ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a00cd1ef90c22b87ea12c2d564f9170ae">assign_array_data_component_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;<a class="el" href="classait.html">type_from_array</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:a00cd1ef90c22b87ea12c2d564f9170ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">In the case of an assignment of an array given a JSON representation, this function assigns the data component of the array, which contains the array elements.  <br /></td></tr>
<tr class="separator:a00cd1ef90c22b87ea12c2d564f9170ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6e693bcc0b4c9c0c07cc1284c190c1" id="r_a0d6e693bcc0b4c9c0c07cc1284c190c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> std::pair&lt; <a class="el" href="classsymbol__exprt.html">symbol_exprt</a>, <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a0d6e693bcc0b4c9c0c07cc1284c190c1">nondet_length</a> (<a class="el" href="classallocate__objectst.html">allocate_objectst</a> &amp;allocate, <a class="el" href="classsource__locationt.html">source_locationt</a> loc)</td></tr>
<tr class="memdesc:a0d6e693bcc0b4c9c0c07cc1284c190c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a non-deterministic length expression.  <br /></td></tr>
<tr class="separator:a0d6e693bcc0b4c9c0c07cc1284c190c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe6129ff8f849fbd7e7997a76baaac1" id="r_a7fe6129ff8f849fbd7e7997a76baaac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> std::pair&lt; <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>, <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a7fe6129ff8f849fbd7e7997a76baaac1">assign_det_length_array_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;<a class="el" href="classait.html">type_from_array</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:a7fe6129ff8f849fbd7e7997a76baaac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where <code>expr</code> represents an array which is not flagged with <code>@nondetLength</code>.  <br /></td></tr>
<tr class="separator:a7fe6129ff8f849fbd7e7997a76baaac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478ae17ff98c591ed4f96c8187ec962f" id="r_a478ae17ff98c591ed4f96c8187ec962f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a478ae17ff98c591ed4f96c8187ec962f">assign_nondet_length_array_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;array, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;<a class="el" href="classait.html">given_length_expr</a>, <a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;<a class="el" href="classait.html">type_from_array</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:a478ae17ff98c591ed4f96c8187ec962f"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where <code>expr</code> represents an array which is flagged with <code>@nondetLength</code>.  <br /></td></tr>
<tr class="separator:a478ae17ff98c591ed4f96c8187ec962f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad255aa7c89bf236e27c0b3144df312c3" id="r_ad255aa7c89bf236e27c0b3144df312c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__frontend__assignt.html">code_frontend_assignt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#ad255aa7c89bf236e27c0b3144df312c3">assign_string_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:ad255aa7c89bf236e27c0b3144df312c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where <code>expr</code> represents a string.  <br /></td></tr>
<tr class="separator:ad255aa7c89bf236e27c0b3144df312c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b40157df640f68d7ba6fd260514e8c" id="r_aa7b40157df640f68d7ba6fd260514e8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#aa7b40157df640f68d7ba6fd260514e8c">assign_struct_components_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:aa7b40157df640f68d7ba6fd260514e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="assignments__from__json_8cpp.html#ac92bcdfc34afe6029eac83ba79f4d7a5">assign_struct_from_json</a> which recursively assigns values to all of the fields of the Java object represented by <code>expr</code> (the components of its type and all of its parent types).  <br /></td></tr>
<tr class="separator:aa7b40157df640f68d7ba6fd260514e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92bcdfc34afe6029eac83ba79f4d7a5" id="r_ac92bcdfc34afe6029eac83ba79f4d7a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#ac92bcdfc34afe6029eac83ba79f4d7a5">assign_struct_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:ac92bcdfc34afe6029eac83ba79f4d7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where <code>expr</code> is a struct, which is the result of dereferencing a pointer that corresponds to the Java object described in <code>json</code>.  <br /></td></tr>
<tr class="separator:ac92bcdfc34afe6029eac83ba79f4d7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af152a5c76f52ee8c78dd08765196998b" id="r_af152a5c76f52ee8c78dd08765196998b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#af152a5c76f52ee8c78dd08765196998b">assign_non_enum_pointer_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:af152a5c76f52ee8c78dd08765196998b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="assignments__from__json_8cpp.html#a31ed5fe8e7cf4cadef86753e3d341ef4">assign_pointer_from_json</a> without special cases (enums).  <br /></td></tr>
<tr class="separator:af152a5c76f52ee8c78dd08765196998b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaaf2c9791efc67155355d629eae084" id="r_afeaaf2c9791efc67155355d629eae084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#afeaaf2c9791efc67155355d629eae084">assign_enum_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:afeaaf2c9791efc67155355d629eae084"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where the expression to be assigned a value is an enum constant that is referenced outside of the definition of its type.  <br /></td></tr>
<tr class="separator:afeaaf2c9791efc67155355d629eae084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ed5fe8e7cf4cadef86753e3d341ef4" id="r_a31ed5fe8e7cf4cadef86753e3d341ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a31ed5fe8e7cf4cadef86753e3d341ef4">assign_pointer_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:a31ed5fe8e7cf4cadef86753e3d341ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where <code>expr</code> is a pointer to a struct, whose type is the same as the runtime-type of the corresponding Java object.  <br /></td></tr>
<tr class="separator:a31ed5fe8e7cf4cadef86753e3d341ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68e9ae27b6f0f7c24b5dae83d1f2e30" id="r_ab68e9ae27b6f0f7c24b5dae83d1f2e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#ab68e9ae27b6f0f7c24b5dae83d1f2e30">assign_pointer_with_given_type_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> <a class="el" href="classjava__class__typet.html">java_class_typet</a> &amp;<a class="el" href="assignments__from__json_8cpp.html#a02397c722097a548695ae9fb9f18a8b8">runtime_type</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:ab68e9ae27b6f0f7c24b5dae83d1f2e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where <code>expr</code> is a pointer to a struct, and <code>runtime_type</code> is the runtime type of the corresponding Java object, which may be more specific than the type pointed to by <code>expr.type()</code> (the compile-time type of the object).  <br /></td></tr>
<tr class="separator:ab68e9ae27b6f0f7c24b5dae83d1f2e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab773d3d33694bd5cf362a1a48b94e479" id="r_ab773d3d33694bd5cf362a1a48b94e479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="structget__or__create__reference__resultt.html">get_or_create_reference_resultt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#ab773d3d33694bd5cf362a1a48b94e479">get_or_create_reference</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> std::string &amp;id, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:ab773d3d33694bd5cf362a1a48b94e479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for <a class="el" href="assignments__from__json_8cpp.html#a2736fbd5003a0e7ed5fcac3832eca837">assign_reference_from_json</a>.  <br /></td></tr>
<tr class="separator:ab773d3d33694bd5cf362a1a48b94e479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2736fbd5003a0e7ed5fcac3832eca837" id="r_a2736fbd5003a0e7ed5fcac3832eca837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#a2736fbd5003a0e7ed5fcac3832eca837">assign_reference_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;<a class="el" href="classait.html">type_from_array</a>, <a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;<a class="el" href="classait.html">info</a>)</td></tr>
<tr class="memdesc:a2736fbd5003a0e7ed5fcac3832eca837"><td class="mdescLeft">&#160;</td><td class="mdescRight">One of the cases in the recursive algorithm: the case where <code>expr</code> corresponds to a Java object that is reference-equal to one or more other Java objects represented in the initial JSON file.  <br /></td></tr>
<tr class="separator:a2736fbd5003a0e7ed5fcac3832eca837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3a79527bc14884f08ecef901937cbe" id="r_adc3a79527bc14884f08ecef901937cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="assignments__from__json_8cpp.html#adc3a79527bc14884f08ecef901937cbe">assign_from_json</a> (<a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;<a class="el" href="properties_8cpp.html#a3956db87b4c264a219fb7b8a5a5eca4b">json</a>, <a class="el" href="classait.html">const</a> <a class="el" href="verification__result_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a> &amp;function_id, <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;symbol_table, std::optional&lt; <a class="el" href="classci__lazy__methods__neededt.html">ci_lazy_methods_neededt</a> &gt; &amp;needed_lazy_methods, <a class="el" href="classait.html">size_t</a> max_user_array_length, std::unordered_map&lt; std::string, <a class="el" href="structobject__creation__referencet.html">object_creation_referencet</a> &gt; &amp;references)</td></tr>
<tr class="memdesc:adc3a79527bc14884f08ecef901937cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression <code>expr</code> representing a Java object or primitive and a JSON representation <code>json</code> of the value of a Java object or primitive of a compatible type, adds statements to <code>block</code> to assign <code>expr</code> to the deterministic value specified by <code>json</code>.  <br /></td></tr>
<tr class="separator:adc3a79527bc14884f08ecef901937cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a00cd1ef90c22b87ea12c2d564f9170ae" name="a00cd1ef90c22b87ea12c2d564f9170ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cd1ef90c22b87ea12c2d564f9170ae">&#9670;&#160;</a></span>assign_array_data_component_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_array_data_component_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_from_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In the case of an assignment of an array given a JSON representation, this function assigns the data component of the array, which contains the array elements. </p>
<p><code>expr</code> is a pointer to the array containing the component. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00392">392</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a7fe6129ff8f849fbd7e7997a76baaac1" name="a7fe6129ff8f849fbd7e7997a76baaac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe6129ff8f849fbd7e7997a76baaac1">&#9670;&#160;</a></span>assign_det_length_array_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> std::pair&lt; <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a>, <a class="el" href="classexprt.html">exprt</a> &gt; assign_det_length_array_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_from_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where <code>expr</code> represents an array which is not flagged with <code>@nondetLength</code>. </p>
<p>The length of the array is given by symbol <code>given_length_expr</code>. We assume that an array with this symbol as its length has already been allocated and that <code>expr</code> has been assigned to it. We constraint the length of the array to be the number of elements, which is known and constant. For the assignment of the array elements, see <a class="el" href="assignments__from__json_8cpp.html#a00cd1ef90c22b87ea12c2d564f9170ae">assign_array_data_component_from_json</a>. For the overall algorithm, see <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p><dl class="section return"><dt>Returns</dt><dd>code for the assignment and length of the created array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00457">457</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="afeaaf2c9791efc67155355d629eae084" name="afeaaf2c9791efc67155355d629eae084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaaf2c9791efc67155355d629eae084">&#9670;&#160;</a></span>assign_enum_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_enum_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where the expression to be assigned a value is an enum constant that is referenced outside of the definition of its type. </p>
<p>(See <a class="el" href="assignments__from__json_8cpp.html#a5c76aa6635d3a662f9f2ba10d5347738">is_enum_with_type_equal_to_declaring_type</a> for this temporary distinction. See <a class="el" href="assignments__from__json_8cpp.html#adc3a79527bc14884f08ecef901937cbe">assign_from_json</a> for details about the recursion.) Once reference-equality of fields in different classes is supported, this function can be removed. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00623">623</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="adc3a79527bc14884f08ecef901937cbe" name="adc3a79527bc14884f08ecef901937cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3a79527bc14884f08ecef901937cbe">&#9670;&#160;</a></span>assign_from_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="verification__result_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a> &amp;&#160;</td>
          <td class="paramname"><em>function_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classci__lazy__methods__neededt.html">ci_lazy_methods_neededt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>needed_lazy_methods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">size_t</a>&#160;</td>
          <td class="paramname"><em>max_user_array_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="structobject__creation__referencet.html">object_creation_referencet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>references</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression <code>expr</code> representing a Java object or primitive and a JSON representation <code>json</code> of the value of a Java object or primitive of a compatible type, adds statements to <code>block</code> to assign <code>expr</code> to the deterministic value specified by <code>json</code>. </p>
<p>The expected format of the JSON representation is mostly the same as that of the json-io serialization library (<a href="https://github.com/jdereg/json-io">https://github.com/jdereg/json-io</a>) if run with the following options, as of version 4.10.1:</p><ul>
<li>A type name map with identity mappings such as <code>("java.lang.Boolean", "java.lang.Boolean")</code> for all primitive wrapper types, java.lang.Class, java.lang.String and java.util.Date. That is, we are not using the json-io default shorthands for those types.</li>
<li><code>WRITE_LONGS_AS_STRINGS</code> should be set to <code>true</code> to avoid a loss of precision when representing longs.</li>
</ul>
<p>Some examples of json-io representations that may not be obvious include:</p><ul>
<li>The representation of a Java object generally may or may not contain a <code>"@type"</code> key. The value corresponding to such a key specifies the runtime type of the object (or the boxed type if the object is primitive). If no <code>"@type"</code> key is present, it is assumed that the runtime type is the same as the compile-time type. Most reference-typed objects are represented as JSON objects (i.e. key-value maps) either way, so the <code>"@type"</code> key is just an additional key in the map. However, primitive types, arrays and string types without a <code>"@type"</code> key are not represented as JSON objects. For example, "untyped" ints are just represented as e.g. 1234, i.e. a JSON number. The "typed" version of this int then becomes <code>{"@type":"java.lang.Integer","value":1234}</code>, i.e. a JSON object, with the original ("untyped") JSON number stored in the "value" entry. For arrays, the corresponding key is called "@items", not "value". Typed versions of primitive types are probably not necessary, but json-io will sometimes produce such values, which is why we support both typed and untyped versions.</li>
<li>The way we deal with reference-equal objects is that they all get assigned the same ID, and exactly one of them will have an <code>{"@id": some_ID}</code> entry, in addition to its usual representation. All the other objects with this ID are represented simply as <code>{"@ref": some_ID}</code>, with no further entries.</li>
</ul>
<p>The above rule has the following exceptions:</p><ul>
<li>It seems that strings are always printed in "primitive" representation by json-io, i.e. they are always JSON strings, and never JSON objects with a <code>@type</code> key. For cases where we don't know that an expression has a string type (e.g. if its type is generic and specialized to java.lang.String), we need to sometimes represent strings as JSON objects with a <code>@type</code> key. In this case, the content of the string will be the value associated with a <code>value</code> key (similarly to StringBuilder in json-io). See <a class="el" href="assignments__from__json_8cpp.html#ac7927787bb04cb7712e5cc547584655f">get_untyped_string</a>.</li>
<li>json-io does not include the <code>ordinal</code> field of enums in its representation, but our algorithm depends on it being present. It may be possible to rewrite parts of it to set the ordinal depending on the order of elements seen in the <code>$VALUES</code> array, but it would generally make things more complicated.</li>
</ul>
<p>For examples of JSON representations of objects, see the regression tests for this feature in jbmc/regression/jbmc/deterministic_assignments_json.</p>
<p>Known limitations:</p><ul>
<li>If two reference-equal objects are defined in the same function, they are correctly assigned the same value. However, the case where they are defined in two different functions is not supported. The object that is stored as a <code>{"@ref":1}</code> or similar will generally either point to a freshly allocated symbol or an out-of-scope symbol. The <code>{"@id":1}</code> (or similar) object may be assigned correctly, or it may point to an out-of-scope symbol. This is because the symbol for the shared value is currently allocated dynamically. To fix this limitation, static allocation would have to be used instead, together with a static boolean to keep track of whether or not the symbol has been allocated already.</li>
<li>The special floating-point values NaN and positive/negative infinity are not supported. Note that in json-io 4.10.1, these are printed as "null". Future versions of json-io will support these values, and this function should be consistent with that if possible.</li>
<li>json-io prints \uFFFF as a single character, which is not read correctly by the JSON parser.</li>
<li>Not all assignments have source locations, and those that do only link to a function, not a line number.</li>
</ul>
<p>For parameter documentation, see <a class="el" href="structobject__creation__infot.html">object_creation_infot</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00914">914</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="ac721bf9c7907cdc3a302f751e21d22e9" name="ac721bf9c7907cdc3a302f751e21d22e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac721bf9c7907cdc3a302f751e21d22e9">&#9670;&#160;</a></span>assign_from_json_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_from_json_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_from_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point of the recursive deterministic assignment algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>expression to assign a deterministic value to. In the case of the entry point, this is either a pointer to a struct, or an expression corresponding to a Java primitive. </td></tr>
    <tr><td class="paramname">json</td><td>a JSON representation of the deterministic value to assign. </td></tr>
    <tr><td class="paramname">type_from_array</td><td>if <code>expr</code> was found as an element of an array, the element type of this array. </td></tr>
    <tr><td class="paramname">info</td><td>references used throughout the recursive algorithm. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00850">850</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="af152a5c76f52ee8c78dd08765196998b" name="af152a5c76f52ee8c78dd08765196998b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af152a5c76f52ee8c78dd08765196998b">&#9670;&#160;</a></span>assign_non_enum_pointer_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_non_enum_pointer_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="assignments__from__json_8cpp.html#a31ed5fe8e7cf4cadef86753e3d341ef4">assign_pointer_from_json</a> without special cases (enums). </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00600">600</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a478ae17ff98c591ed4f96c8187ec962f" name="a478ae17ff98c591ed4f96c8187ec962f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478ae17ff98c591ed4f96c8187ec962f">&#9670;&#160;</a></span>assign_nondet_length_array_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_nondet_length_array_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>given_length_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_from_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where <code>expr</code> represents an array which is flagged with <code>@nondetLength</code>. </p>
<p>The length of the array is given by symbol <code>given_length_expr</code>. We assume that an array with this symbol as its length has already been allocated and that <code>expr</code> has been assigned to it. We constrain the length of the array to be greater or equal to the number of elements specified in <code>json</code>. For the assignment of the array elements, see <a class="el" href="assignments__from__json_8cpp.html#a00cd1ef90c22b87ea12c2d564f9170ae">assign_array_data_component_from_json</a>. For the overall algorithm, see <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p><dl class="section return"><dt>Returns</dt><dd>code for the assignment and length of the created array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00485">485</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a038484071adc18ad6e9d244ec4c72bb6" name="a038484071adc18ad6e9d244ec4c72bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038484071adc18ad6e9d244ec4c72bb6">&#9670;&#160;</a></span>assign_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__frontend__assignt.html">code_frontend_assignt</a> assign_null </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the base cases of the recursive algorithm. </p>
<p>See <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00383">383</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a31ed5fe8e7cf4cadef86753e3d341ef4" name="a31ed5fe8e7cf4cadef86753e3d341ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ed5fe8e7cf4cadef86753e3d341ef4">&#9670;&#160;</a></span>assign_pointer_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_pointer_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where <code>expr</code> is a pointer to a struct, whose type is the same as the runtime-type of the corresponding Java object. </p>
<p>See <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00665">665</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="ab68e9ae27b6f0f7c24b5dae83d1f2e30" name="ab68e9ae27b6f0f7c24b5dae83d1f2e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68e9ae27b6f0f7c24b5dae83d1f2e30">&#9670;&#160;</a></span>assign_pointer_with_given_type_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_pointer_with_given_type_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjava__class__typet.html">java_class_typet</a> &amp;&#160;</td>
          <td class="paramname"><em>runtime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where <code>expr</code> is a pointer to a struct, and <code>runtime_type</code> is the runtime type of the corresponding Java object, which may be more specific than the type pointed to by <code>expr.type()</code> (the compile-time type of the object). </p>
<p>See <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00683">683</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="abe37728a4f16cce9746388108fa9d824" name="abe37728a4f16cce9746388108fa9d824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe37728a4f16cce9746388108fa9d824">&#9670;&#160;</a></span>assign_primitive_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_primitive_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the base cases (primitive case) of the recursion. </p>
<p>For characters, the encoding in <code>json</code> is assumed to be UTF-8. See <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00342">342</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a2736fbd5003a0e7ed5fcac3832eca837" name="a2736fbd5003a0e7ed5fcac3832eca837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2736fbd5003a0e7ed5fcac3832eca837">&#9670;&#160;</a></span>assign_reference_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_reference_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_from_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where <code>expr</code> corresponds to a Java object that is reference-equal to one or more other Java objects represented in the initial JSON file. </p>
<p>See <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. Such an object will either have the key-value pair <code>@id: some_key</code> in <code>json</code>, together with a full representation of the object, or it will only have one key-value pair, <code>@ref: some_key</code>. For each key, there is only one <code>@id</code> field in the JSON file. A special case is enums, which are always represented as a full object without any <code>@id</code> or <code>@ref</code> keys. This is mostly the same as the output from json-io for enums, except that in our representation, we need to include the ordinal field so that e.g. switch statements on enums will work. We keep track of object IDs using a map from IDs to symbol expressions. Usually the ID is the <code>some_key</code> from the example above, except for enums, where the ID is of the form <code>my.package.name.EnumName.CONSTANT</code>. The first time we see an ID (<code>@id</code>, <code>@ref</code> or enum constant), we allocate a symbol for it. The first time we see the full representation of the object (<code>@id</code> or enum constant) we initialize the allocated memory. This strategy may need to be changed to support reference-equality of fields across several different classes (e.g. as soon as we find a <code>@ref</code> for the first time we might want to search the whole initial JSON file for the corresponding <code>@id</code>). </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00794">794</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="ad255aa7c89bf236e27c0b3144df312c3" name="ad255aa7c89bf236e27c0b3144df312c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad255aa7c89bf236e27c0b3144df312c3">&#9670;&#160;</a></span>assign_string_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__frontend__assignt.html">code_frontend_assignt</a> assign_string_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where <code>expr</code> represents a string. </p>
<p>See <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00512">512</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="aa7b40157df640f68d7ba6fd260514e8c" name="aa7b40157df640f68d7ba6fd260514e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b40157df640f68d7ba6fd260514e8c">&#9670;&#160;</a></span>assign_struct_components_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_struct_components_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="assignments__from__json_8cpp.html#ac92bcdfc34afe6029eac83ba79f4d7a5">assign_struct_from_json</a> which recursively assigns values to all of the fields of the Java object represented by <code>expr</code> (the components of its type and all of its parent types). </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00528">528</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="ac92bcdfc34afe6029eac83ba79f4d7a5" name="ac92bcdfc34afe6029eac83ba79f4d7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92bcdfc34afe6029eac83ba79f4d7a5">&#9670;&#160;</a></span>assign_struct_from_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> assign_struct_from_json </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One of the cases in the recursive algorithm: the case where <code>expr</code> is a struct, which is the result of dereferencing a pointer that corresponds to the Java object described in <code>json</code>. </p>
<p>See <a class="el" href="assignments__from__json_8cpp.html#ac721bf9c7907cdc3a302f751e21d22e9">assign_from_json_rec</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00572">572</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a3dafabd375c6f50544c2fa3cb2f9b876" name="a3dafabd375c6f50544c2fa3cb2f9b876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dafabd375c6f50544c2fa3cb2f9b876">&#9670;&#160;</a></span>element_type_from_array_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> std::optional&lt; std::string &gt; element_type_from_array_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_from_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a JSON representation of an array and a type inferred from the type of a containing array, get the element type by removing the leading '['. </p>
<p>Types for arrays are stored in the format "[Lmy.package.name.ClassName;". In this case, the returned value would be "Lmy.package.name.ClassName;". <code>type_from_array</code> would only have a value if this array is stored within another array, i.e. within a ClassName[][]. Keeping track of array types in this way is necessary to assign generic arrays with no compile-time types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>JSON representation of an array. If it contains a <code>@type</code> field, this takes priority over <code>type_from_array</code>. </td></tr>
    <tr><td class="paramname">type_from_array</td><td>may contain a type name from a containing array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the type of an array was given, the type of its elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00307">307</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a2bcaa10bbe1163fa29d7958e8a11db6c" name="a2bcaa10bbe1163fa29d7958e8a11db6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcaa10bbe1163fa29d7958e8a11db6c">&#9670;&#160;</a></span>followed_class_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classjava__class__typet.html">java_class_typet</a> followed_class_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00068">68</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a4969415db571496d7312dce2df54b75d" name="a4969415db571496d7312dce2df54b75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4969415db571496d7312dce2df54b75d">&#9670;&#160;</a></span>get_enum_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> std::string get_enum_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unique ID for an enum, based on its type and <code>name</code> field. </p>
<p>This is needed for the enum workaround until reference-equality across different classes is supported. See <a class="el" href="assignments__from__json_8cpp.html#a5c76aa6635d3a662f9f2ba10d5347738">is_enum_with_type_equal_to_declaring_type</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00171">171</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a3b676c4ba71977f626c51ced8aa075a8" name="a3b676c4ba71977f626c51ced8aa075a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b676c4ba71977f626c51ced8aa075a8">&#9670;&#160;</a></span>get_id_or_reference_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> std::string get_id_or_reference_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unique ID of all objects that are reference-equal to this one. </p>
<p>This is the value corresponding to a "@id" or "@ref" key. See <a class="el" href="assignments__from__json_8cpp.html#a323f0fcacbf786b74ade3e2aef34b5c4">has_id</a> and <a class="el" href="pointer__expr_8h.html#a4a08f9d036e81b2df70912f56e28d3a7">is_reference</a>. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00159">159</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="ab773d3d33694bd5cf362a1a48b94e479" name="ab773d3d33694bd5cf362a1a48b94e479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab773d3d33694bd5cf362a1a48b94e479">&#9670;&#160;</a></span>get_or_create_reference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="structget__or__create__reference__resultt.html">get_or_create_reference_resultt</a> get_or_create_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structobject__creation__infot.html">object_creation_infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for <a class="el" href="assignments__from__json_8cpp.html#a2736fbd5003a0e7ed5fcac3832eca837">assign_reference_from_json</a>. </p>
<p>Look up the given <code>id</code> in the reference map and gets or creates the symbol for it. In the case of arrays, if the first time we see an ID is in a <code>@ref</code> object (rather than <code>@id</code>), we do not know what the length of the array will be, so we need to allocate an array of nondeterministic length. The length will be constrained (in <a class="el" href="assignments__from__json_8cpp.html#a478ae17ff98c591ed4f96c8187ec962f">assign_nondet_length_array_from_json</a>) once we find the corresponding <code>@id</code> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>expression representing the Java object for which a symbol is retrieved or allocated. </td></tr>
    <tr><td class="paramname">id</td><td>key in the reference map for this object </td></tr>
    <tr><td class="paramname">info</td><td>references used throughout the recursive algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair: the first element is true if a new symbol was allocated for the given ID and false if the ID was found in the reference map. The second element has the symbol expression(s) for this ID. </dd></dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00739">739</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a7a95a65e77b1f26c3a7ab55de9337327" name="a7a95a65e77b1f26c3a7ab55de9337327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a95a65e77b1f26c3a7ab55de9337327">&#9670;&#160;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> std::optional&lt; std::string &gt; get_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the argument has a "@type" key, return the corresponding value, else return an empty optional. </p>
<p>A runtime type that is different from the objects compile-time type should be specified in <code>json</code> in this way. Type values are of the format "my.package.name.ClassName". </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00120">120</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a93485d106b775089cb7a764c6aa4f2e0" name="a93485d106b775089cb7a764c6aa4f2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93485d106b775089cb7a764c6aa4f2e0">&#9670;&#160;</a></span>get_untyped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classjsont.html">jsont</a> get_untyped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>object_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For typed versions of primitive, string or array types, looks up their untyped contents with the key specific to their type. </p>
<p>See the examples on <a class="el" href="assignments__from__json_8cpp.html#adc3a79527bc14884f08ecef901937cbe">assign_from_json</a> for the terminology used here (typed vs. untyped). </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00202">202</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="abf13f67d33bcc47ea8f679816972aa14" name="abf13f67d33bcc47ea8f679816972aa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf13f67d33bcc47ea8f679816972aa14">&#9670;&#160;</a></span>get_untyped_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classjson__arrayt.html">json_arrayt</a> get_untyped_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classtypet.html">typet</a> &amp;&#160;</td>
          <td class="paramname"><em>element_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="assignments__from__json_8cpp.html#a93485d106b775089cb7a764c6aa4f2e0">get_untyped</a> for array types. </p>
<p>char arrays are treated as a special case as they are represented as an array of a single String element by json-io, rather than an array of one or more char elements. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00225">225</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a95106a6a6b27f89f134e29cea231743f" name="a95106a6a6b27f89f134e29cea231743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95106a6a6b27f89f134e29cea231743f">&#9670;&#160;</a></span>get_untyped_primitive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classjsont.html">jsont</a> get_untyped_primitive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="assignments__from__json_8cpp.html#a93485d106b775089cb7a764c6aa4f2e0">get_untyped</a> for primitive types. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00215">215</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="ac7927787bb04cb7712e5cc547584655f" name="ac7927787bb04cb7712e5cc547584655f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7927787bb04cb7712e5cc547584655f">&#9670;&#160;</a></span>get_untyped_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classjsont.html">jsont</a> get_untyped_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="assignments__from__json_8cpp.html#a93485d106b775089cb7a764c6aa4f2e0">get_untyped</a> for string types. </p>
<p>Note that this differs from the standard serialization of java.lang.String in json-io, but is consistent with the serialization of StringBuilder and StringBuffer. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00252">252</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="ac62feaacb911cbff0f4cbdf68c6f2528" name="ac62feaacb911cbff0f4cbdf68c6f2528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62feaacb911cbff0f4cbdf68c6f2528">&#9670;&#160;</a></span>has_enum_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a> has_enum_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00076">76</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a323f0fcacbf786b74ade3e2aef34b5c4" name="a323f0fcacbf786b74ade3e2aef34b5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323f0fcacbf786b74ade3e2aef34b5c4">&#9670;&#160;</a></span>has_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a> has_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the argument has a "@id" key. </p>
<p>The presence of such a key means that there exist objects that are reference-equal to this object. The corresponding value is the unique ID of all objects that are reference- equal to this one. All other key-value pairs of <code>json</code> should be as usual. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00136">136</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a46ea9983ba2ce9c9013d0a9e9985772a" name="a46ea9983ba2ce9c9013d0a9e9985772a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ea9983ba2ce9c9013d0a9e9985772a">&#9670;&#160;</a></span>has_nondet_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a> has_nondet_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the argument has a <code>"@nondetLength"<code></code>: true</code> entry. </p>
<p>If such an entry is present on a JSON representation of an array, it means that the array should be assigned a nondeterministic length, constrained to be at least the number of elements specified for this array. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00189">189</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a5c76aa6635d3a662f9f2ba10d5347738" name="a5c76aa6635d3a662f9f2ba10d5347738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c76aa6635d3a662f9f2ba10d5347738">&#9670;&#160;</a></span>is_enum_with_type_equal_to_declaring_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a> is_enum_with_type_equal_to_declaring_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjava__class__typet.html">java_class_typet</a> &amp;&#160;</td>
          <td class="paramname"><em>declaring_class_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used as a workaround until reference-equal objects defined across several classes are tracked correctly. </p>
<p>Once reference-equality works in all cases, this function can be removed. Until then, in the case of an enum expression that needs to be assigned a value, we distinguish between two cases: 1) the declaring class of the enum expression is the same as the type of the enum expression. For example, for an enum Pet {DOG, CAT}, the declaring class of the expression <a class="el" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">Pet.DOG</a> is Pet, and the type of the expression is also Pet. The same is true for the expressions that represent the elements of the $VALUES array of Pet, and for any user-defined Pet-typed fields in Pet.java. In this case, initialize the expression just as a regular object that has known reference-equal objects. (Corresponds to creating the enum constant in Java or referencing it directly.) See assign_reference_from_json. 2) otherwise, initialize it by indexing the $VALUES array with the given ordinal. An example of this case would be the field <code>pet</code> in <code>class MyClass { Pet pet; }</code> (its declaring class is <code>MyClass</code> and its own type is <code>Pet</code>). See assign_enum_from_json. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>an expression representing a Java object. </td></tr>
    <tr><td class="paramname">symbol_table</td><td>used for looking up the type of <code>expr</code>. </td></tr>
    <tr><td class="paramname">declaring_class_type</td><td>type of the class where <code>expr</code> is declared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>expr</code> has an enum type and is declared within the definition of that same type, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00105">105</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a6b055c274a7b9f71152e595d19001f40" name="a6b055c274a7b9f71152e595d19001f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b055c274a7b9f71152e595d19001f40">&#9670;&#160;</a></span>is_reference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> <a class="el" href="classait.html">bool</a> is_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the argument has a "@ref" key. </p>
<p>The corresponding value is the unique ID of all objects that are reference- equal to this one. Any other key-value pairs of <code>json</code> will be ignored. </p>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00148">148</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a0d6e693bcc0b4c9c0c07cc1284c190c1" name="a0d6e693bcc0b4c9c0c07cc1284c190c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d6e693bcc0b4c9c0c07cc1284c190c1">&#9670;&#160;</a></span>nondet_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> std::pair&lt; <a class="el" href="classsymbol__exprt.html">symbol_exprt</a>, <a class="el" href="classcode__with__references__listt.html">code_with_references_listt</a> &gt; nondet_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classallocate__objectst.html">allocate_objectst</a> &amp;&#160;</td>
          <td class="paramname"><em>allocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsource__locationt.html">source_locationt</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a non-deterministic length expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">allocate</td><td>allocation functor </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">loc</td><td>location for the created code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length expression that has been non-deterministically created and the code declaring the expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00433">433</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
<a id="a02397c722097a548695ae9fb9f18a8b8" name="a02397c722097a548695ae9fb9f18a8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02397c722097a548695ae9fb9f18a8b8">&#9670;&#160;</a></span>runtime_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classait.html">static</a> std::optional&lt; <a class="el" href="classjava__class__typet.html">java_class_typet</a> &gt; runtime_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classjsont.html">jsont</a> &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>type_from_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classait.html">const</a> <a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a JSON representation of a (non-array) reference-typed object and a type inferred from the type of a containing array, get the runtime type of the corresponding pointer expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>JSON representation of a non-array object. If it contains a <code>@type</code> field, this takes priority over <code>type_from_array</code>. Types for non- array objects are stored in the JSON in the format "my.package.name.ClassName". </td></tr>
    <tr><td class="paramname">type_from_array</td><td>may contain an element type name given by a containing array. Such types are stored in the form "Lmy.package.name.ClassName;". </td></tr>
    <tr><td class="paramname">symbol_table</td><td>used to look up the type given its name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>runtime type of the object, if specified by at least one of the parameters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="assignments__from__json_8cpp_source.html#l00270">270</a> of file <a class="el" href="assignments__from__json_8cpp_source.html">assignments_from_json.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_a263634046f766d6a2cc27bb1bac298e.html">jbmc</a></li><li class="navelem"><a class="el" href="dir_7d9c2272cea08e738f9482db6f677351.html">src</a></li><li class="navelem"><a class="el" href="dir_1a9aed0dd48ec371a7d28ba0a5a70e7e.html">java_bytecode</a></li><li class="navelem"><a class="el" href="assignments__from__json_8cpp.html">assignments_from_json.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
